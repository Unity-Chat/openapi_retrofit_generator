// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'one_of_element.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$OneOfElement {

@JsonKey(includeIfNull: true) EnumClass? get nullableButRequiredClass;@JsonKey(includeIfNull: true) List<int>? get requiredNullableListNonNullItems;@JsonKey(includeIfNull: true) List<int?>? get requiredNullableListNullableItems; EnumClass get anyClass; List<EnumClass> get oneType;@JsonKey(includeIfNull: true) List<EnumClass>? get nullableType;@JsonKey(includeIfNull: false) EnumClass? get allClass;@JsonKey(includeIfNull: false) EnumClass? get oneClass;@JsonKey(includeIfNull: false) int? get allType;@JsonKey(includeIfNull: false) DateTime? get anyType;@JsonKey(includeIfNull: false) EnumClass? get nullableClass;@JsonKey(includeIfNull: false) List<int>? get nullableListNonNullItems;@JsonKey(includeIfNull: false) List<int?>? get nullableListNullableItems;
/// Create a copy of OneOfElement
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$OneOfElementCopyWith<OneOfElement> get copyWith => _$OneOfElementCopyWithImpl<OneOfElement>(this as OneOfElement, _$identity);

  /// Serializes this OneOfElement to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is OneOfElement&&(identical(other.nullableButRequiredClass, nullableButRequiredClass) || other.nullableButRequiredClass == nullableButRequiredClass)&&const DeepCollectionEquality().equals(other.requiredNullableListNonNullItems, requiredNullableListNonNullItems)&&const DeepCollectionEquality().equals(other.requiredNullableListNullableItems, requiredNullableListNullableItems)&&(identical(other.anyClass, anyClass) || other.anyClass == anyClass)&&const DeepCollectionEquality().equals(other.oneType, oneType)&&const DeepCollectionEquality().equals(other.nullableType, nullableType)&&(identical(other.allClass, allClass) || other.allClass == allClass)&&(identical(other.oneClass, oneClass) || other.oneClass == oneClass)&&(identical(other.allType, allType) || other.allType == allType)&&(identical(other.anyType, anyType) || other.anyType == anyType)&&(identical(other.nullableClass, nullableClass) || other.nullableClass == nullableClass)&&const DeepCollectionEquality().equals(other.nullableListNonNullItems, nullableListNonNullItems)&&const DeepCollectionEquality().equals(other.nullableListNullableItems, nullableListNullableItems));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,nullableButRequiredClass,const DeepCollectionEquality().hash(requiredNullableListNonNullItems),const DeepCollectionEquality().hash(requiredNullableListNullableItems),anyClass,const DeepCollectionEquality().hash(oneType),const DeepCollectionEquality().hash(nullableType),allClass,oneClass,allType,anyType,nullableClass,const DeepCollectionEquality().hash(nullableListNonNullItems),const DeepCollectionEquality().hash(nullableListNullableItems));

@override
String toString() {
  return 'OneOfElement(nullableButRequiredClass: $nullableButRequiredClass, requiredNullableListNonNullItems: $requiredNullableListNonNullItems, requiredNullableListNullableItems: $requiredNullableListNullableItems, anyClass: $anyClass, oneType: $oneType, nullableType: $nullableType, allClass: $allClass, oneClass: $oneClass, allType: $allType, anyType: $anyType, nullableClass: $nullableClass, nullableListNonNullItems: $nullableListNonNullItems, nullableListNullableItems: $nullableListNullableItems)';
}


}

/// @nodoc
abstract mixin class $OneOfElementCopyWith<$Res>  {
  factory $OneOfElementCopyWith(OneOfElement value, $Res Function(OneOfElement) _then) = _$OneOfElementCopyWithImpl;
@useResult
$Res call({
@JsonKey(includeIfNull: true) EnumClass? nullableButRequiredClass,@JsonKey(includeIfNull: true) List<int>? requiredNullableListNonNullItems,@JsonKey(includeIfNull: true) List<int?>? requiredNullableListNullableItems, EnumClass anyClass, List<EnumClass> oneType,@JsonKey(includeIfNull: true) List<EnumClass>? nullableType,@JsonKey(includeIfNull: false) EnumClass? allClass,@JsonKey(includeIfNull: false) EnumClass? oneClass,@JsonKey(includeIfNull: false) int? allType,@JsonKey(includeIfNull: false) DateTime? anyType,@JsonKey(includeIfNull: false) EnumClass? nullableClass,@JsonKey(includeIfNull: false) List<int>? nullableListNonNullItems,@JsonKey(includeIfNull: false) List<int?>? nullableListNullableItems
});




}
/// @nodoc
class _$OneOfElementCopyWithImpl<$Res>
    implements $OneOfElementCopyWith<$Res> {
  _$OneOfElementCopyWithImpl(this._self, this._then);

  final OneOfElement _self;
  final $Res Function(OneOfElement) _then;

/// Create a copy of OneOfElement
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? nullableButRequiredClass = freezed,Object? requiredNullableListNonNullItems = freezed,Object? requiredNullableListNullableItems = freezed,Object? anyClass = null,Object? oneType = null,Object? nullableType = freezed,Object? allClass = freezed,Object? oneClass = freezed,Object? allType = freezed,Object? anyType = freezed,Object? nullableClass = freezed,Object? nullableListNonNullItems = freezed,Object? nullableListNullableItems = freezed,}) {
  return _then(_self.copyWith(
nullableButRequiredClass: freezed == nullableButRequiredClass ? _self.nullableButRequiredClass : nullableButRequiredClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,requiredNullableListNonNullItems: freezed == requiredNullableListNonNullItems ? _self.requiredNullableListNonNullItems : requiredNullableListNonNullItems // ignore: cast_nullable_to_non_nullable
as List<int>?,requiredNullableListNullableItems: freezed == requiredNullableListNullableItems ? _self.requiredNullableListNullableItems : requiredNullableListNullableItems // ignore: cast_nullable_to_non_nullable
as List<int?>?,anyClass: null == anyClass ? _self.anyClass : anyClass // ignore: cast_nullable_to_non_nullable
as EnumClass,oneType: null == oneType ? _self.oneType : oneType // ignore: cast_nullable_to_non_nullable
as List<EnumClass>,nullableType: freezed == nullableType ? _self.nullableType : nullableType // ignore: cast_nullable_to_non_nullable
as List<EnumClass>?,allClass: freezed == allClass ? _self.allClass : allClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,oneClass: freezed == oneClass ? _self.oneClass : oneClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,allType: freezed == allType ? _self.allType : allType // ignore: cast_nullable_to_non_nullable
as int?,anyType: freezed == anyType ? _self.anyType : anyType // ignore: cast_nullable_to_non_nullable
as DateTime?,nullableClass: freezed == nullableClass ? _self.nullableClass : nullableClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,nullableListNonNullItems: freezed == nullableListNonNullItems ? _self.nullableListNonNullItems : nullableListNonNullItems // ignore: cast_nullable_to_non_nullable
as List<int>?,nullableListNullableItems: freezed == nullableListNullableItems ? _self.nullableListNullableItems : nullableListNullableItems // ignore: cast_nullable_to_non_nullable
as List<int?>?,
  ));
}

}


/// Adds pattern-matching-related methods to [OneOfElement].
extension OneOfElementPatterns on OneOfElement {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _OneOfElement value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _OneOfElement() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _OneOfElement value)  $default,){
final _that = this;
switch (_that) {
case _OneOfElement():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _OneOfElement value)?  $default,){
final _that = this;
switch (_that) {
case _OneOfElement() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function(@JsonKey(includeIfNull: true)  EnumClass? nullableButRequiredClass, @JsonKey(includeIfNull: true)  List<int>? requiredNullableListNonNullItems, @JsonKey(includeIfNull: true)  List<int?>? requiredNullableListNullableItems,  EnumClass anyClass,  List<EnumClass> oneType, @JsonKey(includeIfNull: true)  List<EnumClass>? nullableType, @JsonKey(includeIfNull: false)  EnumClass? allClass, @JsonKey(includeIfNull: false)  EnumClass? oneClass, @JsonKey(includeIfNull: false)  int? allType, @JsonKey(includeIfNull: false)  DateTime? anyType, @JsonKey(includeIfNull: false)  EnumClass? nullableClass, @JsonKey(includeIfNull: false)  List<int>? nullableListNonNullItems, @JsonKey(includeIfNull: false)  List<int?>? nullableListNullableItems)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _OneOfElement() when $default != null:
return $default(_that.nullableButRequiredClass,_that.requiredNullableListNonNullItems,_that.requiredNullableListNullableItems,_that.anyClass,_that.oneType,_that.nullableType,_that.allClass,_that.oneClass,_that.allType,_that.anyType,_that.nullableClass,_that.nullableListNonNullItems,_that.nullableListNullableItems);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function(@JsonKey(includeIfNull: true)  EnumClass? nullableButRequiredClass, @JsonKey(includeIfNull: true)  List<int>? requiredNullableListNonNullItems, @JsonKey(includeIfNull: true)  List<int?>? requiredNullableListNullableItems,  EnumClass anyClass,  List<EnumClass> oneType, @JsonKey(includeIfNull: true)  List<EnumClass>? nullableType, @JsonKey(includeIfNull: false)  EnumClass? allClass, @JsonKey(includeIfNull: false)  EnumClass? oneClass, @JsonKey(includeIfNull: false)  int? allType, @JsonKey(includeIfNull: false)  DateTime? anyType, @JsonKey(includeIfNull: false)  EnumClass? nullableClass, @JsonKey(includeIfNull: false)  List<int>? nullableListNonNullItems, @JsonKey(includeIfNull: false)  List<int?>? nullableListNullableItems)  $default,) {final _that = this;
switch (_that) {
case _OneOfElement():
return $default(_that.nullableButRequiredClass,_that.requiredNullableListNonNullItems,_that.requiredNullableListNullableItems,_that.anyClass,_that.oneType,_that.nullableType,_that.allClass,_that.oneClass,_that.allType,_that.anyType,_that.nullableClass,_that.nullableListNonNullItems,_that.nullableListNullableItems);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function(@JsonKey(includeIfNull: true)  EnumClass? nullableButRequiredClass, @JsonKey(includeIfNull: true)  List<int>? requiredNullableListNonNullItems, @JsonKey(includeIfNull: true)  List<int?>? requiredNullableListNullableItems,  EnumClass anyClass,  List<EnumClass> oneType, @JsonKey(includeIfNull: true)  List<EnumClass>? nullableType, @JsonKey(includeIfNull: false)  EnumClass? allClass, @JsonKey(includeIfNull: false)  EnumClass? oneClass, @JsonKey(includeIfNull: false)  int? allType, @JsonKey(includeIfNull: false)  DateTime? anyType, @JsonKey(includeIfNull: false)  EnumClass? nullableClass, @JsonKey(includeIfNull: false)  List<int>? nullableListNonNullItems, @JsonKey(includeIfNull: false)  List<int?>? nullableListNullableItems)?  $default,) {final _that = this;
switch (_that) {
case _OneOfElement() when $default != null:
return $default(_that.nullableButRequiredClass,_that.requiredNullableListNonNullItems,_that.requiredNullableListNullableItems,_that.anyClass,_that.oneType,_that.nullableType,_that.allClass,_that.oneClass,_that.allType,_that.anyType,_that.nullableClass,_that.nullableListNonNullItems,_that.nullableListNullableItems);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _OneOfElement implements OneOfElement {
  const _OneOfElement({@JsonKey(includeIfNull: true) required this.nullableButRequiredClass, @JsonKey(includeIfNull: true) required final  List<int>? requiredNullableListNonNullItems, @JsonKey(includeIfNull: true) required final  List<int?>? requiredNullableListNullableItems, this.anyClass = EnumClass.value1, final  List<EnumClass> oneType = const [], @JsonKey(includeIfNull: true) final  List<EnumClass>? nullableType = const [], @JsonKey(includeIfNull: false) this.allClass, @JsonKey(includeIfNull: false) this.oneClass, @JsonKey(includeIfNull: false) this.allType, @JsonKey(includeIfNull: false) this.anyType, @JsonKey(includeIfNull: false) this.nullableClass, @JsonKey(includeIfNull: false) final  List<int>? nullableListNonNullItems, @JsonKey(includeIfNull: false) final  List<int?>? nullableListNullableItems}): _requiredNullableListNonNullItems = requiredNullableListNonNullItems,_requiredNullableListNullableItems = requiredNullableListNullableItems,_oneType = oneType,_nullableType = nullableType,_nullableListNonNullItems = nullableListNonNullItems,_nullableListNullableItems = nullableListNullableItems;
  factory _OneOfElement.fromJson(Map<String, dynamic> json) => _$OneOfElementFromJson(json);

@override@JsonKey(includeIfNull: true) final  EnumClass? nullableButRequiredClass;
 final  List<int>? _requiredNullableListNonNullItems;
@override@JsonKey(includeIfNull: true) List<int>? get requiredNullableListNonNullItems {
  final value = _requiredNullableListNonNullItems;
  if (value == null) return null;
  if (_requiredNullableListNonNullItems is EqualUnmodifiableListView) return _requiredNullableListNonNullItems;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<int?>? _requiredNullableListNullableItems;
@override@JsonKey(includeIfNull: true) List<int?>? get requiredNullableListNullableItems {
  final value = _requiredNullableListNullableItems;
  if (value == null) return null;
  if (_requiredNullableListNullableItems is EqualUnmodifiableListView) return _requiredNullableListNullableItems;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey() final  EnumClass anyClass;
 final  List<EnumClass> _oneType;
@override@JsonKey() List<EnumClass> get oneType {
  if (_oneType is EqualUnmodifiableListView) return _oneType;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_oneType);
}

 final  List<EnumClass>? _nullableType;
@override@JsonKey(includeIfNull: true) List<EnumClass>? get nullableType {
  final value = _nullableType;
  if (value == null) return null;
  if (_nullableType is EqualUnmodifiableListView) return _nullableType;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey(includeIfNull: false) final  EnumClass? allClass;
@override@JsonKey(includeIfNull: false) final  EnumClass? oneClass;
@override@JsonKey(includeIfNull: false) final  int? allType;
@override@JsonKey(includeIfNull: false) final  DateTime? anyType;
@override@JsonKey(includeIfNull: false) final  EnumClass? nullableClass;
 final  List<int>? _nullableListNonNullItems;
@override@JsonKey(includeIfNull: false) List<int>? get nullableListNonNullItems {
  final value = _nullableListNonNullItems;
  if (value == null) return null;
  if (_nullableListNonNullItems is EqualUnmodifiableListView) return _nullableListNonNullItems;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<int?>? _nullableListNullableItems;
@override@JsonKey(includeIfNull: false) List<int?>? get nullableListNullableItems {
  final value = _nullableListNullableItems;
  if (value == null) return null;
  if (_nullableListNullableItems is EqualUnmodifiableListView) return _nullableListNullableItems;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of OneOfElement
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$OneOfElementCopyWith<_OneOfElement> get copyWith => __$OneOfElementCopyWithImpl<_OneOfElement>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$OneOfElementToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _OneOfElement&&(identical(other.nullableButRequiredClass, nullableButRequiredClass) || other.nullableButRequiredClass == nullableButRequiredClass)&&const DeepCollectionEquality().equals(other._requiredNullableListNonNullItems, _requiredNullableListNonNullItems)&&const DeepCollectionEquality().equals(other._requiredNullableListNullableItems, _requiredNullableListNullableItems)&&(identical(other.anyClass, anyClass) || other.anyClass == anyClass)&&const DeepCollectionEquality().equals(other._oneType, _oneType)&&const DeepCollectionEquality().equals(other._nullableType, _nullableType)&&(identical(other.allClass, allClass) || other.allClass == allClass)&&(identical(other.oneClass, oneClass) || other.oneClass == oneClass)&&(identical(other.allType, allType) || other.allType == allType)&&(identical(other.anyType, anyType) || other.anyType == anyType)&&(identical(other.nullableClass, nullableClass) || other.nullableClass == nullableClass)&&const DeepCollectionEquality().equals(other._nullableListNonNullItems, _nullableListNonNullItems)&&const DeepCollectionEquality().equals(other._nullableListNullableItems, _nullableListNullableItems));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,nullableButRequiredClass,const DeepCollectionEquality().hash(_requiredNullableListNonNullItems),const DeepCollectionEquality().hash(_requiredNullableListNullableItems),anyClass,const DeepCollectionEquality().hash(_oneType),const DeepCollectionEquality().hash(_nullableType),allClass,oneClass,allType,anyType,nullableClass,const DeepCollectionEquality().hash(_nullableListNonNullItems),const DeepCollectionEquality().hash(_nullableListNullableItems));

@override
String toString() {
  return 'OneOfElement(nullableButRequiredClass: $nullableButRequiredClass, requiredNullableListNonNullItems: $requiredNullableListNonNullItems, requiredNullableListNullableItems: $requiredNullableListNullableItems, anyClass: $anyClass, oneType: $oneType, nullableType: $nullableType, allClass: $allClass, oneClass: $oneClass, allType: $allType, anyType: $anyType, nullableClass: $nullableClass, nullableListNonNullItems: $nullableListNonNullItems, nullableListNullableItems: $nullableListNullableItems)';
}


}

/// @nodoc
abstract mixin class _$OneOfElementCopyWith<$Res> implements $OneOfElementCopyWith<$Res> {
  factory _$OneOfElementCopyWith(_OneOfElement value, $Res Function(_OneOfElement) _then) = __$OneOfElementCopyWithImpl;
@override @useResult
$Res call({
@JsonKey(includeIfNull: true) EnumClass? nullableButRequiredClass,@JsonKey(includeIfNull: true) List<int>? requiredNullableListNonNullItems,@JsonKey(includeIfNull: true) List<int?>? requiredNullableListNullableItems, EnumClass anyClass, List<EnumClass> oneType,@JsonKey(includeIfNull: true) List<EnumClass>? nullableType,@JsonKey(includeIfNull: false) EnumClass? allClass,@JsonKey(includeIfNull: false) EnumClass? oneClass,@JsonKey(includeIfNull: false) int? allType,@JsonKey(includeIfNull: false) DateTime? anyType,@JsonKey(includeIfNull: false) EnumClass? nullableClass,@JsonKey(includeIfNull: false) List<int>? nullableListNonNullItems,@JsonKey(includeIfNull: false) List<int?>? nullableListNullableItems
});




}
/// @nodoc
class __$OneOfElementCopyWithImpl<$Res>
    implements _$OneOfElementCopyWith<$Res> {
  __$OneOfElementCopyWithImpl(this._self, this._then);

  final _OneOfElement _self;
  final $Res Function(_OneOfElement) _then;

/// Create a copy of OneOfElement
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? nullableButRequiredClass = freezed,Object? requiredNullableListNonNullItems = freezed,Object? requiredNullableListNullableItems = freezed,Object? anyClass = null,Object? oneType = null,Object? nullableType = freezed,Object? allClass = freezed,Object? oneClass = freezed,Object? allType = freezed,Object? anyType = freezed,Object? nullableClass = freezed,Object? nullableListNonNullItems = freezed,Object? nullableListNullableItems = freezed,}) {
  return _then(_OneOfElement(
nullableButRequiredClass: freezed == nullableButRequiredClass ? _self.nullableButRequiredClass : nullableButRequiredClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,requiredNullableListNonNullItems: freezed == requiredNullableListNonNullItems ? _self._requiredNullableListNonNullItems : requiredNullableListNonNullItems // ignore: cast_nullable_to_non_nullable
as List<int>?,requiredNullableListNullableItems: freezed == requiredNullableListNullableItems ? _self._requiredNullableListNullableItems : requiredNullableListNullableItems // ignore: cast_nullable_to_non_nullable
as List<int?>?,anyClass: null == anyClass ? _self.anyClass : anyClass // ignore: cast_nullable_to_non_nullable
as EnumClass,oneType: null == oneType ? _self._oneType : oneType // ignore: cast_nullable_to_non_nullable
as List<EnumClass>,nullableType: freezed == nullableType ? _self._nullableType : nullableType // ignore: cast_nullable_to_non_nullable
as List<EnumClass>?,allClass: freezed == allClass ? _self.allClass : allClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,oneClass: freezed == oneClass ? _self.oneClass : oneClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,allType: freezed == allType ? _self.allType : allType // ignore: cast_nullable_to_non_nullable
as int?,anyType: freezed == anyType ? _self.anyType : anyType // ignore: cast_nullable_to_non_nullable
as DateTime?,nullableClass: freezed == nullableClass ? _self.nullableClass : nullableClass // ignore: cast_nullable_to_non_nullable
as EnumClass?,nullableListNonNullItems: freezed == nullableListNonNullItems ? _self._nullableListNonNullItems : nullableListNonNullItems // ignore: cast_nullable_to_non_nullable
as List<int>?,nullableListNullableItems: freezed == nullableListNullableItems ? _self._nullableListNullableItems : nullableListNullableItems // ignore: cast_nullable_to_non_nullable
as List<int?>?,
  ));
}


}

// dart format on
